kotrola-kodovani
P\u0159\u00EDli\u0161 \u017Elu\u0165ou\u010Dk\u00FD k\u016F\u0148 \u00FAp\u011Bl \u010F\u00E1belsk\u00E9 \u00F3dy.
P\u0158\u00CDLI\u0160 \u017DLU\u0164OU\u010CK\u00DD K\u016E\u0147 \u00DAP\u011AL \u010E\u00C1BELSK\u00C9 \u00D3DY.

as of release 1.4, 'assert' is a keyword, and may not be used as an identifier
od verze 1.4 je "assert" kl\u00ED\u010Dov\u00E9 slovo a nem\u016F\u017Ee b\u00FDt pou\u017Eito jako identifik\u00E1tor
|
Slovo "assert" je nyn\u00ED sou\u010D\u00E1st\u00ED jazyka Java nesouc\u00ED speci\u00E1ln\u00ED v\u00FDznam
(je to kl\u00ED\u010Dov\u00E9 slovo). Nelze je proto pou\u017E\u00EDt jako identifik\u00E1tor
metody \u010Di prom\u011Bnn\u00E9. Zvolte pros\u00EDm jin\u00FD identifik\u00E1tor (n\u00E1zev).

qualified new of static class
kvalifikovan\u00E9 new p\u0159i konstrukci instance statick\u00E9 t\u0159\u00EDdy
|
Kvalifikovan\u00E9 oper\u00E1tory new se pou\u017E\u00EDvaj\u00ED pouze p\u0159i
vytv\u00E1\u0159en\u00ED instanc\u00ED vnit\u0159n\u00EDch t\u0159\u00EDd, tj. t\u0159\u00EDd, kter\u00E9
jsou deklarovan\u00E9 uvnit\u0159 jin\u00E9 t\u0159\u00EDdy, av\u0161ak bez
modifik\u00E1toru static.

* is abstract; cannot be instantiated
... je abstraktn\u00ED t\u0159\u00EDda - nelze vytvo\u0159it jej\u00ED instanci
|
Tato t\u0159\u00EDda je deklarov\u00E1na jako abstraktn\u00ED
(pomoc\u00ED kl\u00ED\u010Dov\u00E9ho slova "abstract").
Abstraktn\u00ED t\u0159\u00EDdy nemohou vytv\u00E1\u0159et instance.
To mohou a\u017E jejich konkr\u00E9tn\u00ED dce\u0159in\u00E9 t\u0159\u00EDdy.
Konkr\u00E9tn\u00ED t\u0159\u00EDdou je t\u0159\u00EDda, kter\u00E1 m\u00E1 implementov\u00E1ny
v\u0161echny metody implementovan\u00FDch rozhran\u00ED a abstraktn\u00ED
metody rodi\u010Dovsk\u00FDch t\u0159\u00EDd. Tuto implementaci v\u0161ak
m\u016F\u017Ee i zd\u011Bdit.

abstract methods cannot have a body
Abstraktn\u00ED metody nesm\u00ED m\u00EDt t\u011Blo.
|
Pomoc\u00ED kl\u00ED\u010Dov\u00E9ho slova "abstract" jste ozna\u010Dili
metodu jako abstraktn\u00ED a p\u0159itom jste definovali
jej\u00ED t\u011Blo (k\u00F3d ve slo\u017Een\u00FDch z\u00E1vork\u00E1ch).
Deklarace abstraktn\u00EDch metod sm\u011Bj\u00ED obsahovat
pouze hlavi\u010Dku ukon\u010Denou st\u0159edn\u00EDkem.
Bu\u010Fto odstra\u0148te kl\u00ED\u010Dov\u00E9 slovo "abstract", nebo
sma\u017Ete t\u011Blo metody v\u010Detn\u011B slo\u017Een\u00FDch z\u00E1vorek a
ukon\u010Dete hlavi\u010Dku metody st\u0159edn\u00EDkem.

* is already defined in *
... je ji\u017E definov\u00E1na v ...
|
Uvnit\u0159 t\u00E9to metody je ji\u017E definov\u00E1na
prom\u011Bnn\u00E1/odkaz nebo parametr se stejn\u00FDm
jm\u00E9nem. P\u0159ejete-li si vytvo\u0159it novou
prom\u011Bnnou/odkaz pou\u017Eijte jin\u00E9 jm\u00E9no.
Chcete-li pou\u017E\u00EDt st\u00E1vaj\u00EDc\u00ED prom\u011Bnnou nebo
parametr odstra\u0148te typ prom\u011Bnn\u00E9/odkazu.

anonymous class implements interface; cannot have arguments
anonymn\u00ED t\u0159\u00EDda inplementuj\u00EDc\u00ED rozhran\u00ED nesm\u00ED m\u00EDt parametry
|
P\u0159esn\u011Bji \u0159e\u010Deno v definici anonymn\u00ED t\u0159\u00EDdy mus\u00EDte v hlavi\u010Dce
za deklarac\u00ED implementovan\u00E9ho rozhran\u00ED uv\u00E9st pouze
pr\u00E1zdn\u00E9 kulat\u00E9 z\u00E1vorky ().

anonymous class implements interface; cannot have qualifier for new
nonymn\u00ED t\u0159\u00EDda inplementuj\u00EDc\u00ED rozhran\u00ED nesm\u00ED m\u00EDt kvalifikovan\u00E9 new
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

array required, but *
Je vy\u017Eadov\u00E1no pole, ale uveden\u00FD typ je ...
|
Pou\u017E\u00EDv\u00E1te syntaxi p\u0159\u00EDstupu k element\u016Fm pole pomoc\u00ED
hranat\u00FDch z\u00E1vorek. Prom\u011Bnn\u00E1 ale nen\u00ED typu pole.

break outside switch or loop
P\u0159\u00EDkaz "break" je pou\u017Eit mimo "switch" nebo cyklus
|
P\u0159\u00EDkaz "break" ukon\u010D\u00ED vykon\u00E1v\u00E1n\u00ED bloku "switch"
nebo cyklu "for", "while" \u010Di "do".
P\u0159\u00EDkaz "break" nesm\u00ED b\u00FDt pou\u017Eit mimo tyto bloky.

* must be first statement in constructor
... mus\u00ED b\u00FDt uveden jako prvn\u00ED p\u0159\u00EDkaz v konstruktoru
|
Vol\u00E1-li konstruktor jin\u00FD konstruktor prost\u0159ednictv\u00EDm
this nebo super, mus\u00ED b\u00FDt toto vol\u00E1n\u00ED \u00FApln\u011B prvn\u00EDm
p\u0159\u00EDkazem v t\u011Ble konstruktoru. P\u0159ed t\u00EDmto p\u0159\u00EDkazem
nesm\u00ED b\u00FDt nic: \u017E\u00E1dn\u00FD p\u0159\u00EDkaz ani za\u010D\u00E1tek bloku
nebo uvozen\u00ED bloku try ... catch.
Jsou povoleny pouze b\u00EDl\u00E9 znaky a koment\u00E1\u0159e.

cannot access *
Nelze p\u0159istupovat k ...
|
Pravd\u011Bpodobn\u011B se sna\u017E\u00EDte p\u0159istupovat k metod\u011B
\u010Di objektu, kter\u00FD nen\u00ED z tohoto m\u00EDsta viditeln\u00FD.
Nej\u010Dast\u011Bj\u0161\u00EDm d\u016Fvodem je pokus a pou\u017Eit\u00ED prom\u011Bnn\u00E9
vn\u011B bloku, v n\u011Bm\u017E byl definov\u00E1na.

cannot assign a value to final variable *
Nelze p\u0159i\u0159adit hodnotu konstant\u011B ...
|
Kl\u00ED\u010Dov\u00FDm slovem "final" jsou ozna\u010Den\u00E9 konstanty.
Jejich hodnota nesm\u00ED b\u00FDt v programu zm\u011Bn\u011Bna.
Pt\u0159ebujete-li hodnotu prom\u011Bnn\u00E9 m\u011Bnit,
odstra\u0148te v jej\u00ED deklaraci modifik\u00E1tor final.

type variables cannot be dereferenced
prom\u011Bnn\u00E9 primitivn\u00EDch typ\u016F nemohou b\u00FDt dereferencov\u00E1ny
|
U prom\u011Bnn\u00FDch a atribut\u016F primitivn\u00EDch typ\u016F nem\u016F\u017Eete
pou\u017E\u00EDt te\u010Dkovou konvenci a sna\u017Eit se oslovit
jejich slo\u017Eky.

* cannot be dereferenced
... nem\u016F\u017Ee b\u00FDt dereferencov\u00E1na
|
Pomoc\u00ED oper\u00E1toru "." se sna\u017E\u00EDte p\u0159istoupit k metod\u011B
nebo atributu prom\u011Bnn\u00E9, kter\u00E1 nen\u00ED objektov\u00E9ho typu.

cannot inherit from final *
Nelze d\u011Bdit/odvozovat od "final" t\u0159\u00EDdy ...
|
Rodi\u010Dovsk\u00E1 t\u0159\u00EDda (tj. t\u0159\u00EDda, od kter\u00E9 se odvozuje,
a kter\u00E1 je uveden\u00E1 za kl\u00ED\u010Dov\u00FDm slovem "extends")
je deklarov\u00E1na jako "final", co\u017E zakazuje vytv\u00E1\u0159en\u00ED
jej\u00EDch potomk\u016F (dce\u0159inn\u00FDch t\u0159\u00EDd).

* before supertype constructor has been called
... bylo vol\u00E1no p\u0159ed konstruktorem rodi\u010Dovsk\u00E9 t\u0159\u00EDdy
|
Prvn\u00ED v\u011Bc, kter\u00E1 by m\u011Bla b\u00FDt provedena v konstruktoru
dce\u0159inn\u00E9 t\u0159\u00EDdy (podt\u0159\u00EDdy), je vol\u00E1n\u00ED konstruktoru
rodi\u010Dovsk\u00E9 t\u0159\u00EDdy. Nem\u00E1-li rodi\u010Dovsk\u00E1 t\u0159\u00EDda implicitn\u00ED
konstruktor, mus\u00EDte pou\u017E\u00EDt p\u0159\u00EDkazu
    super(...);
uveden\u00E9ho jako prvn\u00ED p\u0159\u00EDkaz t\u011Bla konstruktoru.
Te\u010Dky p\u0159edstavuj\u00ED parametry konstruktoru.
Stejn\u00FD p\u0159\u00EDkaz pou\u017Eijte i p\u0159i pot\u0159eb\u011B vol\u00E1n\u00ED jin\u00E9ho
ne\u017E bezparametrick\u00E9ho rodi\u010Dovsk\u00E9ho konstruktoru.

cannot return a value from method whose result type is void
Nelze vracet hodnoty z metody ozna\u010Den\u00E9 "void"
|
Deklarace n\u00E1vratov\u00E9ho typu "void" znamen\u00E1, \u017Ee metoda nevrac\u00ED
\u017E\u00E1dnou hodnotu. V t\u011Ble "void" metody lze pou\u017E\u00EDt pouze p\u0159\u00EDkaz
"return;", tj. bez ud\u00E1n\u00ED n\u00E1vratov\u00E9 hodnoty.

cannot select a static class from a parameterized type
Z parametrizovan\u00E9ho typu nen\u00ED mo\u017En\u00E9 vybrat statickou t\u0159\u00EDdu
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

* cannot be inherited with different arguments: *
... nem\u016F\u017Ee b\u00FDt zd\u011Bd\u011Bno s odli\u0161n\u00FDmi parametry: ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

'catch' without 'try'
Je pou\u017Eit p\u0159\u00EDkaz 'catch' bez p\u0159edchoz\u00EDho 'try'
|
"catch" je kl\u00ED\u010Dov\u00E9 slovo, kter\u00E9 m\u016F\u017Ee b\u00FDt pou\u017Eito pouze
po bloku "try". Spr\u00E1vn\u00E9 pou\u017Eit\u00ED:
   try {
      p\u0159\u00EDkazy ...
   }
   catch(Exception e) {
     p\u0159\u00EDkazy ...
   }

* clashes with package of same name
... koliduje se stejn\u011B pojmenovan\u00FDm bal\u00ED\u010Dkem
|
Ujist\u011Bte se, \u017Ee t\u0159\u00EDda a bal\u00ED\u010Dek, ve kter\u00E9m je t\u0159\u00EDda
um\u00EDst\u011Bna, maj\u00ED rozd\u00EDln\u00E1 jm\u00E9na. Podle konvence by m\u011Bla
jm\u00E9na t\u0159\u00EDd za\u010D\u00EDnat velk\u00FDmi p\u00EDsmeny a jm\u00E9na bal\u00ED\u010Dk\u016F
by m\u011Bla obsahovat pouze mal\u00E1 p\u00EDsmena.

code too large for try statement
K\u00F3d uvnit\u0159 bloku 'try' je p\u0159\u00EDli\u0161 dlouh\u00FD
|
Uvnit\u0159 tohoto "try" bloku je p\u0159\u00EDli\u0161 mnoho \u0159\u00E1dk\u016F.
Pokuste se p\u0159esunout tento k\u00F3d do nov\u00E9 metody
a zavolejte ji z tohoto bloku.

constant expression required
Je vy\u017Eadov\u00E1n konstantn\u00ED v\u00FDraz
|
Na tomto m\u00EDst\u011B je vy\u017Eadov\u00E1no pou\u017Eit\u00ED konstantn\u00EDho
v\u00FDrazu, kter\u00FD je mo\u017Eno vyhodnotit ji\u017E v dob\u011B p\u0159ekladu.
Jako konstatn\u00ED v\u00FDraz je mo\u017Eno pou\u017E\u00EDt v\u00FDraz obsahuj\u00EDc\u00ED
pouze liter\u00E1ly a jin\u00E9 konstantn\u00ED v\u00FDrazy.

continue outside of loop
P\u0159\u00EDkaz 'continue' je pou\u017Eit mimo cyklus
|
P\u0159\u00EDkaz "continue" je pou\u017E\u00EDv\u00E1n k okam\u017Eit\u00E9mu
p\u0159echodu do dal\u0161\u00EDho opakov\u00E1n\u00ED cyklu. Tento
p\u0159\u00EDkaz m\u016F\u017Ee b\u00FDt pou\u017Eit pouze uvnit\u0159 cyklu
"for", "while" a "do".

cyclic inheritance involving *
Cyklick\u00E1 d\u011Bdi\u010Dnost v ...
|
Sna\u017E\u00EDte se tuto t\u0159\u00EDdu odvodit od t\u0159\u00EDdy,
kter\u00E1 je sama od t\u00E9to t\u0159\u00EDdy odvozena.
Jin\u00FDmi slovy: sna\u017E\u00EDte se, aby rodi\u010D byl
potomkem sv\u00E9ho potomka. Mus\u00EDte se rozhodnout,
kter\u00E1 t\u0159\u00EDda bude rodi\u010D a kter\u00E1 potomek.

* does not exist
... neexistuje
|
Pravd\u011Bpodobn\u011B jste zde cht\u011Bli pou\u017E\u00EDt jm\u00E9no
prom\u011Bnn\u00E9 nebo t\u0159\u00EDdy, av\u0161ak \u017E\u00E1dn\u00E1 prom\u011Bnn\u00E1,
t\u0159\u00EDda nebo bal\u00ED\u010Dek s takov\u00FDm jm\u00E9nem neexistuje.

duplicate class:*
Duplicitn\u00ED t\u0159\u00EDda: ...
|
T\u0159\u00EDda se stejn\u00FDm jm\u00E9nem ji\u017E existuje.

duplicate case label
Duplicitn\u00ED n\u00E1v\u011B\u0161t\u00ED 'case'
|
Uvnit\u0159 bloku "switch" jste pou\u017Eili dvakr\u00E1t "case xx:"
se stejnou hodnotou. To nen\u00ED p\u0159\u00EDpustn\u00E9.

duplicate default label
Duplicitn\u00ED n\u00E1v\u011B\u0161t\u00ED 'default'
|
Uvnit\u0159 bloku "switch" m\u016F\u017Ee b\u00FDt n\u00E1v\u011B\u0161t\u00ED "default"
pou\u017Eito pouze jednou.

'else' without 'if'
'else' je pou\u017Eito bez p\u0159edchoz\u00EDho 'if'
|
Kl\u00ED\u010Dov\u00E9 slovo "else" m\u016F\u017Ee b\u00FDt pou\u017Eito pouze
jako sou\u010D\u00E1st p\u0159\u00EDkazu "if". P\u0159\u00EDklad:
   if (podm\u00EDnka)
     p\u0159\u00EDkaz-vykonan\u00FD-p\u0159\u00ED-spln\u011Bn\u00ED-podm\u00EDnky
   else
     p\u0159\u00EDkaz-vykonan\u00FD-p\u0159\u00ED-NEspln\u011Bn\u00ED-podm\u00EDnky
Mo\u017En\u00E1, \u017Ee jste neuvedli spr\u00E1vn\u00FD po\u010Det slo\u017Een\u00FDch z\u00E1vorek.
\u010Castou p\u0159\u00ED\u010Dinou t\u00E9to chyby je, \u017Ee chcete ve v\u011Btvi if vykonat
n\u011Bkolik p\u0159\u00EDkaz\u016F a zapomn\u011Bli jste je uzav\u0159\u00EDt do slo\u017Een\u00FDch z\u00E1vorek.
   if (podm\u00EDnka)
   {
      p\u0159\u00EDkaz1;
      p\u0159\u00EDkaz2;
   }
   else
   {
      p\u0159\u00EDkaz3;
   }

empty character literal
Zak\u00E1zan\u00FD znak ''
|
Znakov\u00E9 liter\u00E1ly se p\u00ED\u0161\u00ED ve tvaru 'a'. Mezi apostrofy
je v\u017Edy pr\u00E1v\u011B jeden znak. V\u00FDjimkou jsou speci\u00E1ln\u00ED
znaky psan\u00E9 pomoc\u00ED zp\u011Btn\u00E9ho lom\u00EDtka - nap\u0159.
'\n' nov\u00FD \u0159\u00E1dek, '\t' tabul\u00E1tor atd.
Pr\u00E1zdn\u00FD znak neexistuje.

* has already been caught
... v\u00FDjimka ji\u017E byla zachycena
|
Tento "catch" je zbyte\u010Dn\u00FD,
proto\u017Ee se do tohoto m\u00EDsta v\u00FDjimka nikdy nedostane.
V\u0161echny deklarovan\u00E9 v\u00FDjimky budou zachyceny
pomoc\u00ED p\u0159edchoz\u00EDch "catch".

* is never thrown in body of corresponding try statement
... v\u00FDjimka nem\u016F\u017Ee b\u00FDt vyvol\u00E1na v p\u0159\u00EDslu\u0161n\u00E9m "try" bloku
|
Zachyt\u00E1v\u00E1te v\u00FDjimku, kterou v p\u0159\u00EDslu\u0161n\u00E9m bloku try
nikdo negeneruje.

'finally' without 'try'
Pou\u017Eito 'finally' bez p\u0159edchoz\u00EDho 'try'
|
"finally" je kl\u00ED\u010Dov\u00E9 slovo, kter\u00E9 m\u016F\u017Ee b\u00FDt pou\u017Eito pouze
po "try" bloku. Pou\u017Eit\u00ED:
   try {
      p\u0159\u00EDkazy;
   }
   catch(Exception e) {
     p\u0159\u00EDkazy;
   }
   finally {
      p\u0159\u00EDkazy;
   }

floating point number too large
zadan\u00E9 desetinn\u00E9 \u010D\u00EDslo je p\u0159\u00EDli\u0161 velik\u00E9
|
Syst\u00E9m neum\u00ED pracovat s tak velk\u00FDmi \u010D\u00EDsly
dan\u00E9ho typu.

floating point number too small
zadan\u00E9 desetinn\u00E9 \u010D\u00EDslo je p\u0159\u00EDli\u0161 mal\u00E9
|
Syst\u00E9m neum\u00ED pracovat s tak mal\u00FDmi \u010D\u00EDsly
dan\u00E9ho typu.

inner classes cannot have static declarations
Vnit\u0159n\u00ED t\u0159\u00EDda nem\u016F\u017Ee m\u00EDt statick\u00E9 deklarace
|
Ve vnit\u0159n\u00ED t\u0159\u00EDd\u011B nelze deklarovat statick\u00E9 \u010Dleny.
Pot\u0159ebujete-li statick\u00FD atribut nebo metodu,
rozmyslete si, zda dan\u00E1 t\u0159\u00EDda nem\u016F\u017Ee b\u00FDt
deklarov\u00E1na pouze jako vno\u0159en\u00E1 (tj. s modifik\u00E1torem
static), anebo vytvo\u0159te po\u017Eadovan\u00FD atribut
\u010Di metodu ve vn\u011Bj\u0161\u00ED t\u0159\u00EDd\u011B.

illegal character: *
Zak\u00E1zan\u00FD znak: ...
|
Na tomto \u0159\u00E1dku je ve zdrojov\u00E9m k\u00F3du zak\u00E1zan\u00FD znak.
Tento znak nemus\u00ED b\u00FDt viditeln\u00FD. Nem\u016F\u017Eete-li jej
nal\u00E9zt, sma\u017Ete cel\u00FD \u0159\u00E1dek a napi\u0161te jej znovu.

illegal combination of modifiers: *
Zak\u00E1zan\u00E1 kombinace modifik\u00E1tor\u016F: ...
|
Pou\u017Eili jste zak\u00E1zanou kombinaci modifik\u00E1tor\u016F,
kter\u00E9 se navz\u00E1jem vylu\u010Duj\u00ED.
P\u0159\u00EDkladem je kombinace modifik\u00E1toru "abstract"
s n\u011Bkter\u00FDm z modifik\u00E1tor\u016F "native",
"final", "private" nebo "synchronized".

illegal escape character
Neplatn\u00E1 escape sekvence
|
Escape sekvence za\u010D\u00EDn\u00E1 zp\u011Btn\u00FDm lom\u00EDtkem "\"
n\u00E1sledovan\u00FDm p\u00EDsmenem. Povolen\u00E9 znaky jsou:
\n, \t, \b, \r, \f, \\, \', \".

illegal forward reference
Nepovlen\u00FD dop\u0159edn\u00FD odkaz
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

illegal initializer for *
Nepovolen\u00FD incializ\u00E1tor pro ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

illegal line end in character literal
Neplatn\u00FD konec \u0159\u00E1dku uvnit\u0159 znakov\u00E9ho liter\u00E1lu
|
\u0158\u00E1dek v\u00E1m kon\u010D\u00ED uprost\u0159ed znakov\u00E9ho liter\u00E1lu.
Znak pro nov\u00FD \u0159\u00E1dek je '\n'.

illegal qualifier; {0} is not an inner class
nepovolen\u00FD modifik\u00E1tor; ... nen\u00ED vnit\u0159n\u00ED t\u0159\u00EDda
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

illegal start of expression
Zak\u00E1zan\u00FD za\u010D\u00E1tek v\u00FDrazu
|
Na t\u00E9to pozici, je o\u010Dek\u00E1v\u00E1n po\u010D\u00E1tek v\u00FDrazu,
ale je zde n\u011Bco jin\u00E9ho. Pravd\u011Bpodobn\u011B v\u00E1m
v p\u0159edchoz\u00EDm k\u00F3du n\u011Bco p\u0159eb\u00FDv\u00E1 nebo chyb\u00ED.
Zkontrolujte spr\u00E1vnost definice typu.

illegal start of type
Zak\u00E1zan\u00FD za\u010D\u00E1tek typu
|
Na t\u00E9to pozici, je o\u010Dek\u00E1v\u00E1no jm\u00E9no typu,
ale je zde n\u011Bco jin\u00E9ho Pravd\u011Bpodobn\u011B v\u00E1m
v p\u0159edchoz\u00EDm k\u00F3du n\u011Bco p\u0159eb\u00FDv\u00E1 nebo chyb\u00ED.
Zkontrolujte spr\u00E1vnost definice typu.

illegal unicode escape
Zak\u00E1zan\u00FD z\u00E1pis znaku sady unicode
|
Znaky definovan\u00E9 k\u00F3dem je mo\u017Eno zad\u00E1vat sekvenc\u00ED
\uXXXX
kde X zastupuje hexadecim\u00E1ln\u00ED \u010D\u00EDslici. Tyto \u010D\u00EDslice
mus\u00ED b\u00FDt v\u017Edy pr\u00E1v\u011B 4.

improperly formed type, some parameters are missing
Nespr\u00E1vn\u011B utvo\u0159en\u00FD typ, n\u011Bkter\u00E9 parametry chyb\u011Bj\u00ED
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

incomparable types: *
Tyto typy nelze navz\u00E1jem porovn\u00E1vat: ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

integer number too large: *
Cel\u00E9 \u010D\u00EDslo je p\u0159\u00EDli\u0161 velk\u00E9: ...
|
Napsali jste \u010D\u00EDslo, kter\u00E9 je pro tento typ p\u0159\u00EDli\u0161
dlouh\u00E9. Zkuste pou\u017E\u00EDt del\u0161\u00ED typ ("int" nebo "long").

internal error; cannot instantiate *
Vnit\u0159n\u00ED chyba; nen\u00ED mo\u017Eno vytvo\u0159it instanci ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

* but with different return type
... existuje s jin\u00FDm typem n\u00E1vratov\u00E9 hodnoty
|
Pravd\u011Bpodobn\u011B se sna\u017E\u00EDte definovat dv\u011B metody, kter\u00E9 se
li\u0161\u00ED pouze v typu n\u00E1vratov\u00E9 hodnoty. To nen\u00ED dovoleno.
Metody, kter\u00E9 maj\u00ED stejn\u00FD n\u00E1zev, se mus\u00ED li\u0161it
v po\u010Dtu a/nebo typu parametr\u016F.

interface expected here
Zde je o\u010Dek\u00E1v\u00E1no rozhran\u00ED
|
Rodi\u010Dem rozhran\u00ED m\u016F\u017Ee b\u00FDt pouze rozhran\u00ED.
Jm\u00E9no, kter\u00E9 jste uvedli po "extends" nen\u00ED rozhran\u00ED.

interface methods cannot have body
Metoda deklrovan\u00E1 v rozhran\u00ED nem\u016F\u017Ee m\u00EDt t\u011Blo
|
Rozhran\u00ED m\u016F\u017Ee obsahovat pouze hlavi\u010Dky metod
ukon\u010Den\u00E9 st\u0159edn\u00EDkem. Metody deklarovan\u00E9 v rozhran\u00ED
nesm\u00ED m\u00EDt definov\u00E1no t\u011Blo ve slo\u017Een\u00FDch z\u00E1vork\u00E1ch.

hexadecimal numbers must contain at least one hexadecimal digit
Hexadecim\u00E1ln\u00ED \u010D\u00EDsla mus\u00ED b\u00FDt tvo\u0159ena alespo\u0148 jednou \u010D\u00EDslic\u00ED
|
Zadali jste hexadecim\u00E1ln\u00ED \u010D\u00EDslo pomoc\u00ED z\u00E1pisu "0x".
P\u0159i z\u00E1pisu hexa \u010D\u00EDsla mus\u00ED b\u00FDt po "x" uvedena alespo\u0148 jedna
\u010D\u00EDslice 0...9 nebo a...f nebo A...F.

invalid method declaration; return type required
Neplatn\u00E1 deklarace metody; chyb\u00ED typ n\u00E1vratov\u00E9 hodnoty
|
V\u0161echny metody mus\u00ED m\u00EDt v hlavi\u010Dce uveden typ n\u00E1vratov\u00E9 hodnoty.
Vrac\u00ED-li nap\u0159. mojeMetoda() textov\u00FD \u0159et\u011Bzec, mus\u00ED m\u00EDt hlavi\u010Dku:
    public String mojeMetoda();
Metody, kter\u00E9 nic nevrac\u00ED maj\u00ED uveden\u00FD typ "void" - nap\u0159.:
    public void jinaMetoda();
N\u011Bco v\u0161ak v\u017Edy m\u00EDt uvedeno mus\u00ED.
.
\u010Castou p\u0159\u00ED\u010Dinou t\u00E9to chyby b\u00FDv\u00E1 \u0161patn\u00E9 pojmenov\u00E1n\u00ED konstruktoru,
kter\u00E9 neodpov\u00EDd\u00E1 n\u00E1zvu t\u0159\u00EDdy, tak\u017Ee jej pak p\u0159eklada\u010D omylem
pova\u017Euje za standardn\u00ED metodu.

* already in use
... u\u017E je pou\u017Eito
|
V programu je ji\u017E definov\u00E1na prom\u011Bnn\u00E1 nebo
parametr t\u00EDmto jm\u00E9nem. P\u0159ejete-li si vytvo\u0159it
novou prom\u011Bnnou, pou\u017Eijte jin\u00E9 jm\u00E9no. Chcete-li
pou\u017E\u00EDt st\u00E1vaj\u00EDc\u00ED prom\u011Bnnou nebo parametr
odstra\u0148te z p\u0159\u00EDkazu deklaraci typu.

* is accessed from within inner class; needs to be declared final
... je pou\u017Eito ve vnit\u0159n\u00ED t\u0159\u00EDd\u011B => mus\u00ED b\u00FDt 'final'
|
Pokou\u0161\u00EDte se z vnit\u0159n\u00ED t\u0159\u00EDdy p\u0159istoupit k atributu jej\u00ED vn\u011Bj\u0161\u00ED
t\u0159\u00EDdy \u010Di k lok\u00E1ln\u00ED prom\u011Bnn\u00E9 metody, v n\u00ED\u017E je t\u0159\u00EDda definov\u00E1na.
Z vnit\u0159n\u00EDch t\u0159\u00EDd v\u0161ak m\u016F\u017Eete p\u0159istupovat pouze ke kostant\u00E1m.
M\u00E1te dv\u011B mo\u017Enosti: bu\u010Fto p\u0159id\u00E1n\u00EDm modifik\u00E1toru 'final' ud\u011Blejte
z pou\u017Eit\u00E9 prom\u011Bnn\u00E9 konstatnu, nebo nebo pro ni definujte
ve vn\u011Bj\u0161\u00ED t\u0159\u00EDd\u011B metody get... a set... a p\u0159istupujte k n\u00ED
prost\u0159ednictv\u00EDm t\u011Bchto metod.

malformed floating point literal
Chyba p\u0159i z\u00E1pisu \u010D\u00EDsla s plovouc\u00ED desetinnou te\u010Dkou
|
P\u0159i z\u00E1pisu \u010D\u00EDsla s plovouc\u00ED desetinou te\u010Dko jste
ud\u011Blali n\u011Bjakou chybu.
POZOR: v \u010De\u0161tin\u011B - desetinn\u00E1 \u010D\u00E1rka; v Jav\u011B - te\u010Dka !!
P\u0159\u00EDklady korektn\u00EDho z\u00E1pisu:
18.0      18.     1.8e1     .18E2

missing method body, or declare abstract
Chyb\u00ED t\u011Blo metody, nebo kl\u00ED\u010Dov\u00E9 slovo 'abstract'
|
Metoda mus\u00ED m\u00EDt t\u011Blo, nebo mus\u00ED b\u00FDt definov\u00E1na jako
abstraktn\u00ED. T\u011Blo metody je uv\u00E1d\u011Bno ve slo\u017Een\u00FDch z\u00E1vork\u00E1ch.
Abstraktn\u00ED metody nemaj\u00ED t\u011Blo, jsou ozna\u010Deny modifik\u00E1torem
'abstract' a hlavi\u010Dka metody je ukon\u010Dena st\u0159edn\u00EDkem - nap\u0159.
    public abstract int getOdpoved();

missing return statement
Chyb\u00ED p\u0159\u00EDkaz 'return'
|
Tato metoda m\u00E1 definov\u00E1n n\u00E1vratov\u00FD typ. Mus\u00ED proto
vracet n\u00E1vratovou hodnotu pomoc\u00ED p\u0159\u00EDkazu
     return <v\u00FDraz>;
nap\u0159.
     return 42;
Vracen\u00FD typ mus\u00ED odpov\u00EDdat typu uveden\u00E9mu v hlavi\u010Dce
metody. Metody, kter\u00E9 nemaj\u00ED vracet \u017E\u00E1dnou hodnotu
mus\u00ED m\u00EDt deklarov\u00E1n typ n\u00E1vratov\u00E9 hodnoty "void".

missing return value
U p\u0159\u00EDkazu return chyb\u00ED hodnota
|
P\u0159\u00EDkaz "return;" bez ud\u00E1n\u00ED n\u00E1vratov\u00E9 hodnoty m\u016F\u017Ee b\u00FDt
pou\u017Eit pouze u "void" metod. Metody, u kter\u00FDch je uveden
typ n\u00E1vratov\u00E9 hodnoty, mus\u00ED vracet hodnotu dan\u00E9ho typu.
P\u0159\u00EDklad:
    return 42*x;
nebo
    return "Marvin";

name clash: *
Kolize jmen: ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

* is reserved for internal use
... je rezervov\u00E1no pro intern\u00ED pou\u017Eit\u00ED
|
Uveden\u00E9 slovo je rezervov\u00E1no, proto nem\u016F\u017Ee b\u00FDt
pou\u017Eito jako jm\u00E9no prom\u011Bnn\u00E9/reference nebo t\u0159\u00EDdy.

native methods cannot have a body
Metoda s modifik\u00E1torem 'native' nesm\u00ED m\u00EDt t\u011Blo
|
Tato metoda je ozna\u010Den\u00E1 jako "native" a z\u00E1rove\u0148 m\u00E1
t\u011Blo. Nativn\u00ED metody maj\u00ED pouze hlavi\u010Dku ukon\u010Denou
st\u0159edn\u00EDkem.

no enclosing instance of type {0} is in scope
Neuzav\u0159en\u00ED instance typu ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

no interface expected here
Na tomto m\u00EDst\u011B nem\u016F\u017Ee b\u00FDt pou\u017Eito rozhran\u00ED
|
Pravd\u011Bpodobn\u011B se pokou\u0161\u00EDte odvodit t\u0159\u00EDdu od rozhran\u00ED
pomoc\u00ED slova "extends". T\u0159\u00EDdu lze odvodit pouze od
jin\u00E9 t\u0159\u00EDdy, nikoliv od rozhran\u00ED. Chcete-li, aby
tato t\u0159\u00EDda implementovala dan\u00E9 rozhran\u00ED, pou\u017Eijte
kl\u00ED\u010Dov\u00E9 slovo "implements".

{0} has no match in entry in {1}; required {2}
... nesouhlas\u00ED se vstupem v ...; je po\u017Eadov\u00E1no ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

* is not defined in a public class or interface; cannot be accessed from outside package
... nen\u00ED deklarov\u00E1na jako ve\u0159ejn\u00E1 t\u0159\u00EDda nebo rozhran\u00ED => nem\u016F\u017Ee b\u00FDt pou\u017Eite vn\u011B bal\u00ED\u010Dku
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

* cannot be accessed from outside package
... nem\u016F\u017Ee b\u00FDt pou\u017Eito mimo bal\u00ED\u010Dek
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

not a loop label: *
Nen\u00ED n\u00E1v\u011B\u0161t\u00EDm cyklu: ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

not a statement
To nen\u00ED p\u0159\u00EDkaz
|
Napsali jste k\u00F3d, kter\u00FD nen\u00ED p\u0159\u00EDkazem. Zkontrolujte
znovu tento \u0159\u00E1dek.

not an enclosing class: *
T\u0159\u00EDda nen\u00ED vn\u011Bj\u0161\u00ED t\u0159\u00EDdou: ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

* cannot be applied to *
 ... oper\u00E1tor \u010Di metoda nem\u016F\u017Ee b\u00FDt pou\u017Eit(a) pro ...
|
Oper\u00E1tor, resp. metoda, kterou se zde pokou\u0161\u00EDte pou\u017E\u00EDt,
nem\u016F\u017Ee b\u00FDt pro tento datov\u00FD typ pou\u017Eit(a).
Pou\u017E\u00EDv\u00E1te bu\u010Fto \u0161patn\u00FD typ dat, nebo nevhodn\u00FD oper\u00E1tor.
Chyba je \u010Dasto vyvol\u00E1na t\u00EDm, \u017Ee pou\u017E\u00EDjete takovou
sadu parametr\u016F, pro kterou nen\u00ED definov\u00E1na pot\u0159ebn\u00E1
p\u0159et\u00ED\u017Een\u00E1 verze dan\u00E9 metody.

* clashes with class of same name
 ... koliduje se stejn\u011B pojmenovanou t\u0159\u00EDdou
|
Ujist\u011Bte se, \u017Ee t\u0159\u00EDda a bal\u00ED\u010Dek maj\u00ED odli\u0161n\u00E1 jm\u00E9na.
Jm\u00E9na t\u0159\u00EDd za\u010D\u00EDnaj\u00ED velk\u00FDmi p\u00EDsmeny, jm\u00E9na
bal\u00ED\u010Dk\u016F za\u010D\u00EDnaj\u00ED mal\u00FDmi p\u00EDsmeny.

possible fall-through into case
Pravd\u011Bpodobn\u00FD propad do v\u011Btve case"
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

error reading *
Chyba p\u0159i \u010Dten\u00ED ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

recursive constructor invocation
Rekurzivn\u00ED vol\u00E1n\u00ED konstruktoru
|
Vytvo\u0159ili jste konstruktor, kter\u00FD vol\u00E1 s\u00E1m sebe.
To nen\u00ED p\u0159\u00EDpustn\u00E9, proto\u017Ee by pravd\u011Bpodobn\u011B
vznikl nekone\u010Dn\u00FD cyklus.

* is ambiguous, both *
... je zam\u011Bniteln\u00E9 s ...
|
Ur\u010Den\u00ED jm\u00E9na t\u0159\u00EDdy nebo rozhran\u00ED nen\u00ED jednozna\u010Dn\u00E9.
Pravd\u011Bpodobn\u011B importujete z r\u016Fzn\u00FDch bal\u00ED\u010Dk\u016F t\u0159\u00EDdy
nebo rozhran\u00ED se stejn\u00FDm jm\u00E9nem. Tento probl\u00E9m
vy\u0159e\u0161\u00EDte pou\u017Eit\u00EDm pln\u00E9ho jm\u00E9na t\u0159\u00EDdy, nap\u0159\u00EDklad:
    import java.util.List;
nebo
    java.util.List lst;

repeated interface
Opakovan\u00E9 uveden\u00ED rozhran\u00ED
|
Po "implements" bylo jedno rozhran\u00ED uvedeno opakovan\u011B.
Pou\u017Eit\u00E9 rozhran\u00ED m\u016F\u017Ee b\u00FDt uvedeno pouze jednou.

repeated modifier
Opakovan\u00E9 uveden\u00ED modifik\u00E1toru
|
Modifik\u00E1tor byl uveden opakovan\u011B. Modifik\u00E1tory
"final, static, public, private, volatile, ..."
se uv\u00E1d\u011Bj\u00ED pouze jednou.

{0} has {1} access in {2}
... m\u00E1 ... p\u0159\u00EDstup\u016F v ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

return outside method
P\u0159\u00EDkaz return je pou\u017Eit vn\u011B metod
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

signature does not match {0}; incompatible interfaces
Hlavi\u010Dka neodpov\u00EDd\u00E1 ...; nekopmatibiln\u00ED rozhran\u00ED
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

signature does not match {0}; incompatible supertype
Hlavi\u010Dka neodpov\u00EDd\u00E1 ...; nekopmatibiln\u00ED rodi\u010Dovsk\u00FD typ
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

* should be declared abstract; it does not define *
 ... by m\u011Bla b\u00FDt deklarov\u00E1na jako 'abstract'; nen\u00ED definov\u00E1no ...
|
Tato t\u0159\u00EDda nedefinuje v\u0161echny metody uveden\u00E9
v pou\u017Eit\u00FDch rozhran\u00EDch nebo neimplementuje
n\u011Bjakou abstraktn\u00ED metodu rodi\u010Dovsk\u00E9 t\u0159\u00EDdy.
Bu\u010F mus\u00EDte tuto metodu implementovat
nebo deklarovat t\u0159\u00EDdu jako abstraktn\u00ED

* is not abstract and does not override abstract method *
... nen\u00ED abstraktn\u00ED a p\u0159itom neimplementuje abstratn\u00ED metodu ...
|
Nej\u010Dast\u011Bj\u0161\u00ED p\u0159\u00ED\u010Dinou chyby je nedefinovan\u00E1 metoda
vy\u017Eadovan\u00E1 implementovan\u00FDm rozhran\u00EDm.
|
Obecn\u011B tato chybov\u00E9 hl\u00E1\u0161ka tvrd\u00ED,
\u017Ee jste definovali konkr\u00E9tn\u00ED (tj. ne abstraktn\u00ED) t\u0159\u00EDdu,
kter\u00E1 implementuje n\u011Bjak\u00E9 rozhran\u00ED,
resp. je potomkem n\u011Bjak\u00E9 abstraktn\u00ED t\u0159\u00EDdy,
a p\u0159itom jste neimplementovali v\u0161echny metody
deklarovan\u00E9 v dan\u00E9m rozhran\u00ED,
resp. nep\u0159ekryli v\u0161echny abstraktn\u00ED metody dan\u00E9 t\u0159\u00EDdy.
|
V chybov\u00E9m hl\u00E1\u0161en\u00ED je uvedena konkr\u00E9tn\u00ED neimplementovan\u00E1 metoda.
Mus\u00EDte t\u0159\u00EDdu definovat jako abstraktn\u00ED
nebo implementovat p\u0159\u00EDslu\u0161nou metodu.

error writing source; cannot overwrite input file *
Chyba p\u0159i zapisov\u00E1n\u00ED zdroje; nelze p\u0159epsat vstupn\u00ED soubor ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

'try' without 'catch' or 'finally'
Pou\u017Eit\u00ED 'try' bez 'catch' nebo 'finally'
|
Pou\u017Eijete-li blok "try", mus\u00EDte jej ukon\u010Dit
pomoc\u00ED "catch" nebo "finally". Spr\u00E1vn\u00E9 pou\u017Eit\u00ED:
   try {
      p\u0159\u00EDkazy;
   }
   catch(Exception e) {
      p\u0159\u00EDkazy;
   }
   finally {
      p\u0159\u00EDkazy;
   }

* does not take parameters
... nem\u00E1 parametry
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

wrong number of type arguments; required *
Nespr\u00E1vn\u00FD po\u010Det parametr\u016F; po\u017Eadov\u00E1no ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
Typov\u00E1 prom\u011Bnn\u00E1 ... se vyskytuje ve v\u00FDsledku typu ... v\u00EDce ne\u017E jednou; je t\u0159eba vytvo\u0159it instanci
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
Typov\u00E1 prom\u011Bnn\u00E1 ... se vyskytuje ve typu ... v\u00EDce ne\u017E jednou; je t\u0159eba vytvo\u0159it instanci
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

unclosed character literal
Neukon\u010Den\u00FD znakov\u00FD liter\u00E1l
|
Pravd\u011Bpodobn\u011B jste zapomn\u011Bli ukon\u010Dit znak pomoc\u00ED apostrofu: '.

unclosed comment
Neukon\u010Den\u00FD koment\u00E1\u0159
|
Komet\u00E1\u0159 mus\u00ED za\u010D\u00EDnat dvojic\u00ED znak\u016F "/*"
a b\u00FDt ukon\u010Den dvojic\u00ED znak\u016F "*/".

unclosed string literal
Neukon\u010Den\u00FD znakov\u00FD \u0159et\u011Bzec
|
Textov\u00FD \u0159et\u011Bzec mus\u00ED b\u00FDt uzav\u0159en v uvozovk\u00E1ch (").
Pot\u0159ebujete-li vlo\u017Eit do \u0159et\u011Bzce uvozovky, pou\u017Eijte
'\"', pot\u0159ebujete-li vlo\u017Eit nov\u00FD \u0159\u00E1dek, pou\u017Eijte '\n'.

undefined label: *
Nedefinovan\u00E9 ozna\u010Den\u00ED: ...
|
Prom\u011Bnn\u00E1 s t\u00EDmto jm\u00E9nem v dan\u00E9 oblasti neexistuje.
Mo\u017En\u00E1 jste ud\u011Blali chybu ve jm\u00E9nu (pozor na velk\u00E1
a mal\u00E1 p\u00EDsmena), nebo je prom\u011Bnn\u00E1 definov\u00E1na uvnit\u0159
n\u011Bjak\u00E9ho vno\u0159en\u00E9ho bloku. Obecn\u011B \u0159e\u010Deno: prom\u011Bnn\u00E1
se stane neviditelnou ihned po koncov\u00E9 "}" bloku,
v n\u011Bm\u017E je definov\u00E1na.

unreachable statement
P\u0159\u00EDkaz nebude nikdy vykon\u00E1n
|
Tento p\u0159\u00EDkaz nebude nikdy vykon\u00E1n. Metody
nesm\u00ED obsahovat k\u00F3d, kter\u00FD nem\u016F\u017Ee b\u00FDt nikdy
vykon\u00E1n. Nej\u010Dast\u011Bji se jedn\u00E1 o p\u0159\u00EDkaz stoj\u00EDc\u00ED
bezprost\u0159edn\u011B za p\u0159\u00EDkazem return nebo za
vychozen\u00EDm v\u00FDjimky. Ov\u011B\u0159te p\u0159\u00EDkazy, kter\u00E9 ovliv\u0148uj\u00ED
vykon\u00E1v\u00E1n\u00ED k\u00F3du, pop\u0159\u00EDpad\u011B tento k\u00F3d vyma\u017Ete.

initializer must be able to complete normally
Statick\u00FD blok mus\u00ED b\u00FDt ukon\u010Den norm\u00E1ln\u011B
|
Statick\u00FD blok zastupuj\u00EDc\u00ED statick\u00FD konstruktor nesm\u00ED vyvolat
kontrolovanou v\u00FDjimku, tj. v\u00FDjimku, kter\u00E1 je potomkem t\u0159\u00EDdy
Exception a nen\u00ED potomkem t\u0159\u00EDdy RuntimeException.

* must be caught or declared to be thrown
v\u00FDjimka ... mus\u00ED b\u00FDt zachycena nebo deklarov\u00E1na jako vyvol\u00E1van\u00E1
|
V hlavi\u010Dce metody mus\u00ED b\u00FDt uvedeny v\u0161echny v\u00FDjimky,
kter\u00E9 mohou v t\u011Ble metody nastat a nejsou uvnit\u0159 metody
zachyceny. To znamen\u00E1: metoda zachyt\u00ED v\u00FDjimku pomoc\u00ED
bloku "try", nebo je v z\u00E1hlav\u00ED metody uvedeno "throws"
n\u00E1sledovan\u00E9 t\u0159\u00EDdou v\u00FDjimky.
P\u0159\u00EDklad zachycen\u00ED:
   try
   {
      ...
   }
   catch(...)
   {
      ...
   }
P\u0159\u00EDklad p\u0159ed\u00E1n\u00ED v\u00FDjimky d\u00E1le:
   public void mojeMetoda() throws NejakaVyjimka

'void' type not allowed here
Typ 'void' zde nelze pou\u017E\u00EDt
|
Typ "void" je mo\u017Eno pou\u017E\u00EDt pouze pro metody.
Nelze ho pou\u017E\u00EDt pro prom\u011Bnn\u00E9 nebo reference.

* not allowed here
... nen\u00ED zde povolen
|
Pou\u017Eili jste modifik\u00E1tor ("private", "protected", ...)
na m\u00EDst\u011B, kde to nen\u00ED p\u0159\u00EDpustn\u00E9.

* might already have been assigned to
... p\u0159i\u0159azen\u00ED u\u017E mohlo b\u00FDt provedeno
|
Konstant\u011B sm\u00ED b\u00FDt p\u0159i\u0159azena hodnota pouze jednou.
Statick\u00E9 konstanty mus\u00ED b\u00FDt inicializov\u00E1ny v deklaraci
nebo statick\u00E9m bloku, intan\u010Dn\u00ED konstanty mus\u00ED b\u00FDt
inicializov\u00E1ny v deklaraci nebo konstruktoru.

* might not have been initialized
... nemus\u00ED b\u00FDt inicializov\u00E1no
|
Prom\u011Bnn\u00E1 mus\u00ED b\u00FDt p\u0159ed prvn\u00EDm pou\u017Eit\u00EDm inicializovan\u00E1.

variable {0} might be assigned in loop
prom\u011Bnn\u00E9 ... m\u016F\u017Ee b\u00FDt p\u0159i\u0159azena hodnota v cyklu
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

error while writing *
Chyba p\u0159i z\u00E1pisu ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

* is public, should be declared in a file named *
 .. je deklarov\u00E1no jako 'public' a proto mus\u00ED b\u00FDt v souboru pojmenovan\u00E9m ...
|
Zdrojov\u00FD k\u00F3d ve\u0159ejn\u00FDch t\u0159\u00EDd mus\u00ED b\u00FDt v souboru se shodn\u00FDm jm\u00E9nem
jako je jm\u00E9no t\u0159\u00EDdy a s p\u0159\u00EDponou .java.
P\u0159\u00EDklad: t\u0159\u00EDda "Neco" mus\u00ED b\u00FDt v souboru "Neco.java".

cannot read: *
Nelze \u010D\u00EDst: ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

* uses or overrides a deprecated API.
... pou\u017E\u00EDv\u00E1 nebo p\u0159ekr\u00FDv\u00E1 metodu, kter\u00E1 je 'deprecated'
|
Pou\u017E\u00EDv\u00E1n\u00ED "deprectated" (zastaral\u00FDch) metod se nedoporu\u010Duje.
P\u0159e\u010Dt\u011Bte si pros\u00EDm dokumentaci a pou\u017Eijte jej\u00ED nov\u011Bj\u0161\u00ED n\u00E1hra\u017Eku.

* has been deprecated
... je 'deprecated'
|
Pou\u017E\u00EDv\u00E1n\u00ED t\u00E9to metody nen\u00ED doporu\u010Deno, tato metoda byla ozna\u010Dena
jako zastaral\u00E1. P\u0159e\u010Dt\u011Bte si pros\u00EDm dokumentaci a najd\u011Bte si jej\u00ED
nov\u011Bj\u0161\u00ED n\u00E1hra\u017Eku.

';' expected
Je o\u010Dek\u00E1v\u00E1n st\u0159edn\u00EDk
|
Ka\u017Ed\u00FD p\u0159\u00EDkaz mus\u00ED b\u00FDt ukon\u010Den st\u0159edn\u00EDkem.
Chyba je pravd\u011Bpodobn\u011B na tomto nebo
na p\u0159edchoz\u00EDm \u0159\u00E1dku. Chyba b\u00FDv\u00E1 ob\u010Das
zavle\u010Dena d\u00EDky \u0161patn\u011B uzav\u0159en\u00FDm z\u00E1vork\u00E1m
nebo uvozovk\u00E1m.

'case', 'default' or '}' expected
Je o\u010Dek\u00E1v\u00E1no 'case', 'defaul', nebo '}'
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

'class' or 'interface' expected
Je o\u010Dek\u00E1v\u00E1no 'class', nebo 'interface'
|
Pobl\u00ED\u017E po\u010D\u00E1tku souboru je o\u010Dek\u00E1v\u00E1no kl\u00ED\u010Dov\u00E9 slovo
"class" nebo "interface". Nebylo zde nalezeno nebo je
p\u0159ed n\u00EDm n\u011Bco, co tam nepat\u0159\u00ED.

'.class' expected
Je o\u010Dek\u00E1v\u00E1no .class
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

'(' or '[' expected
Je o\u010Dek\u00E1v\u00E1no '(', nebo '['
|
Zd\u00E1 se, \u017Ee si po\u010Det lev\u00FDch a prav\u00FDch z\u00E1vorek neodpov\u00EDd\u00E1.

* expected
... o\u010Dek\u00E1v\u00E1no
|
Na ozna\u010Den\u00E9 pozici je ve zdrojov\u00E9m k\u00F3du o\u010Dek\u00E1v\u00E1n
uveden\u00FD symbol. M\u00EDsto n\u011Bj tu v\u0161ak byl nalezen jin\u00FD
symbol. Pokuste se odhalit, p\u0159o\u010D p\u0159eklada\u010D o\u010Dek\u00E1v\u00E1
na ozna\u010Den\u00E9m m\u00EDst\u011B uveden\u00FD symbol.

orphaned *
Opu\u0161t\u011Bn\u00E9 ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

cannot access *
Nelze p\u0159istupovat k ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

type parameter {0} is not within its bound *
Parametr ... nen\u00ED uvnit\u0159 sv\u00FDch mez\u00ED ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

type parameters of {0} cannot be determined
Typ parametru nen\u00ED mo\u017Eno ur\u010Dit
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

incompatible types *
Nekompatibiln\u00ED typy ...
|
Na tomto m\u00EDst\u011B je o\u010Dek\u00E1v\u00E1n jin\u00FD datov\u00FD typ.
P\u0159iklad: uvedli jste typ "String" na m\u00EDst\u011B,
kde je o\u010Dek\u00E1v\u00E1n typ "int".

inconvertible types *
Konverze typ\u016F nen\u00ED mo\u017En\u00E1
|
Typ uveden\u00FD na tomto m\u00EDst\u011B nem\u016F\u017Ee b\u00FDt automaticky konvertov\u00E1n.

possible loss of precision
Pravd\u011Bpodobn\u00E1 ztr\u00E1ta p\u0159esnosti
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

unexpected type
Neo\u010Dek\u00E1van\u00FD typ
|
Na tomto m\u00EDst\u011B je vy\u017Eadov\u00E1n v\u00FDraz n\u011Bjak\u00E9ho typu.
V programu je v\u0161ak v\u00FDraz jin\u00E9ho typu, kter\u00FD nen\u00ED
s po\u017Eadovan\u00FDm typem kompatibiln\u00ED (nap\u0159. pou\u017E\u00EDv\u00E1te
String v m\u00EDst\u011B, kde je vy\u017Eadov\u00E1n int).

abstract {0} {1} cannot be accessed directly
Abstraktn\u00ED ...  ... nem\u016F\u017Ee b\u00FDt p\u0159\u00EDmo pou\u017Eito
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

*An explicit 'this' qualifier must be used to select the desired instance.
... k v\u00FDb\u011Bru po\u017Eadovan\u00E9 instance mus\u00ED b\u00FDt pou\u017Eit explicitn\u00ED kvalifik\u00E1tor "this"
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

* cannot be referenced from a static context
... nemohou b\u00FDt pou\u017Eity ve statick\u00E9m kontextu
|
Pokou\u0161\u00EDte se pou\u017E\u00EDt atribut nebo metodu instance
ve statick\u00E9 metod\u011B. To nen\u00ED povoleno. Instan\u010Dn\u00ED atributy
a metody n\u00E1le\u017Eej\u00ED v\u017Edy n\u011Bjak\u00E9mu objektu. Ten zde ale
nem\u00E1te uveden. Instan\u010Dn\u00ED metody a atributy mohou b\u00FDt
pou\u017E\u00EDv\u00E1ny pouze v metod\u00E1ch instanc\u00ED. P\u0159i pou\u017Eit\u00ED
ve statick\u00FDm metod\u00E1ch mus\u00EDte explicitn\u011B uv\u00E9st
jejich objekt.

cannot find symbol*
nelze naj\u00EDt symbol...
|
Na tomto m\u00EDst\u011B pou\u017E\u00EDv\u00E1te symbol (n\u00E1zev prom\u011Bnn\u00E9, metody \u010Di t\u0159\u00EDdy),
kter\u00FD nebyl deklarov\u00E1n nikde, kam je odsud "ved\u011Bt".
Ov\u011B\u0159te, zda se jedn\u00E1 o p\u0159eklep nebo zda jste pouze zapomn\u011Bli
dan\u00FD symbol deklarovat.
Dal\u0161\u00ED mo\u017Enost\u00ED je, \u017Ee jste jej deklarovali n\u011Bkde,
kam odsud "nen\u00ED vid\u011Bt" - nap\u0159. uvnit\u0159 n\u011Bkter\u00E9ho z p\u0159edchoz\u00EDch blok\u016F.

cannot resolve symbol *
Nelze rozpoznat symbol ...
|
Na ozna\u010Den\u00E9m m\u00EDst\u011B pou\u017E\u00EDv\u00E1te symbol (jm\u00E9no prom\u011Bn\u00E9, t\u0159\u00EDdy nebo
metody), kter\u00E1 nen\u00ED deklarov\u00E1n\u00E1 v \u017E\u00E1dn\u00E9 viditeln\u00E9 oblasti.
Zkontrolujte, zda jste neud\u011Blali p\u0159eklep nebo zda jste
danou prom\u011Bnnou nezapomn\u011Bli deklarovat. Objev\u00EDte-li chybu,
napravte ji.

{0}; {1} and {2} are static
...; ... a ... jsou statick\u00E9
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

{0}; overridden method is {1}
...; p\u0159ekryvn\u00E1 metoda je ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

* attempting to assign weaker access privileges; was *
Pokus o p\u0159i\u0159azen\u00ED slab\u0161\u00EDch p\u0159\u00EDstupov\u00FDch pr\u00E1v
|
P\u0159\u00EDstupov\u00E1 pr\u00E1va ke atribut\u016Fm a metod\u00E1m dce\u0159inn\u00FDch t\u0159\u00EDd
nesm\u00ED b\u00FDt p\u0159\u00EDsn\u011Bj\u0161\u00ED ne\u017E p\u0159\u00EDstupov\u00E1 pr\u00E1va k t\u011Bm\u017Ee \u010Dlen\u016Fm
rodi\u010Dovsk\u00FDch t\u0159\u00EDd.

* overridden method does not throw *
P\u0159ekryt\u00E1 metoda ... nevyvol\u00E1v\u00E1 v\u00FDjimku ...
|
P\u0159ekryli jste metodu a vyvol\u00E1v\u00E1te zde v\u00FDjimku.
P\u0159ekryt\u00E9 metody nemohou vyhazovat jin\u00E9 v\u00FDjimky
ne\u017E jejich rodi\u010De.

* attempting to use incompatible return type
... sna\u017E\u00EDte se pou\u017E\u00EDt nekompatibiln\u00ED v\u00FDstupn\u00ED typ hodnoty
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

* is already defined in this compilation unit
... je ji\u017E v t\u00E9to p\u0159ekladov\u00E9 jednotce definov\u00E1no
|
Pou\u017Eili jste stejn\u00E9 jm\u00E9no dvakr\u00E1t.
Pou\u017Eijte jin\u00FD identifik\u00E1tor.

{0} is already defined in a single-type import
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

* conflicts with a compiler-synthesized symbol in *
... koliduje se symbolem vytvo\u0159en\u00FDm p\u0159eklada\u010Dem v ...
|
Podrobn\u011Bj\u0161\u00ED n\u00E1pov\u011Bda nen\u00ED k dispozici.

reached end of file while parsing
p\u0159i anal\u00FDze bylo dosa\u017Eeno konce souboru
|
Nejsp\u00ED\u0161e jste pomoc\u00ED '{' otev\u0159eli n\u011Bjak\u00FD blok,
kter\u00FD jste pak zapomn\u011Bli zav\u0159\u00EDt odpov\u00EDdaj\u00EDc\u00ED '}'.
Bu\u010Fto v\u00E1m n\u011Bkde p\u0159eb\u00FDv\u00E1 otev\u00EDrac\u00ED z\u00E1vorka,
nebo jste zapomn\u011Bli napsat z\u00E1vorku zav\u00EDrac\u00ED.
P\u0159i hled\u00E1n\u00ED chyby m\u016F\u017Eete v editoru vyu\u017E\u00EDt funkce
zv\u00E1razn\u011Bn\u00ED p\u00E1rov\u00FDch z\u00E1vorek.
