package antlr;

/**
 * <b>SOFTWARE RIGHTS</b>
 * <p>
 * ANTLR 2.5.0 MageLang Institute, 1998
 * <p>
 * We reserve no legal rights to the ANTLR--it is fully in the
 * public domain. An individual or company may do whatever
 * they wish with source code distributed with ANTLR or the
 * code generated by ANTLR, including the incorporation of
 * ANTLR, or its output, into commerical software.
 * <p>
 * We encourage users to develop software with ANTLR. However,
 * we do ask that credit is given to us for developing
 * ANTLR. By "credit", we mean that if you use ANTLR or
 * incorporate any source code into one of your programs
 * (commercial product, research project, or otherwise) that
 * you acknowledge this fact somewhere in the documentation,
 * research report, etc... If you like ANTLR and have
 * developed a nice tool with the output, please mention that
 * you developed it using ANTLR. In addition, we ask that the
 * headers remain intact in our source code. As long as these
 * guidelines are kept, we expect to continue enhancing this
 * system and expect to make other tools available as they are
 * completed.
 * <p>
 * The ANTLR gang:
 * @version ANTLR 2.5.0 MageLang Institute, 1998
 * @author Terence Parr, <a href=http://www.MageLang.com>MageLang Institute</a>
 * @author <br>John Lilley, <a href=http://www.Empathy.com>Empathy Software</a>
 */
import antlr.collections.impl.Vector;

/**A list of alternatives */
class AlternativeBlock extends AlternativeElement {
	protected String initAction = null;	// string for init action {...}
	protected Vector alternatives;	// Contains Alternatives

	protected String label;			// can label a looping block to break out of it.

	protected int alti, altj;		// which alts are being compared at the moment with
									// deterministic()?
	protected int analysisAlt;		// which alt are we computing look on?  Must be alti or altj

	protected boolean hasAnAction = false;	// does any alt have an action?
	protected boolean hasASynPred = false;	// does any alt have a syntactic predicate?

	protected int ID=0;				// used to generate unique variables
	protected static int nblks;	// how many blocks have we allocated?
	boolean not = false;				// true if block is inverted.

	// JEL removed this because it was only used for synpred, and it was
	// screwed up by the shell game played by EBNF replacing a subrule block
	// with another block.
	//protected AlternativeBlock enclosingBlock;
	
	protected boolean doAutoGen=true;	// false if no AST (or text) to be generated for block

	protected boolean warnWhenFollowAmbig = true; // warn when an empty path or exit path

	protected boolean generateAmbigWarnings = true;  // the general warning "shut-up" mechanism

																	// conflicts with alt of subrule.
																	// Turning this off will suppress stuff
																	// like the if-then-else ambig.

	public AlternativeBlock(Grammar g) {
		this(g,0,false);
	}
	public AlternativeBlock(Grammar g, int line, boolean not) {
		super(g);
		alternatives = new Vector(5);
		this.line = line;
		this.not = not;
		nblks++;
		ID = nblks;
	}
	public void addAlternative(Alternative alt) {
		alternatives.appendElement(alt);
	}
	public void generate() {
		grammar.generator.gen(this);
	}
	public Alternative getAlternativeAt(int i)
	{
		return (Alternative)alternatives.elementAt(i);
	}
	public Vector getAlternatives() {
		return alternatives;
	}
	public boolean getAutoGen() { 
		return doAutoGen; 
	}
	public String getInitAction() { 
		return initAction;
	}
	public String getLabel() {
		return label;
	}
	public Lookahead look(int k) {
		return grammar.theLLkAnalyzer.look(k, this);
	}
	public void prepareForAnalysis() {
		for (int i=0; i<alternatives.size(); i++) {
			// deterministic() uses an alternative cache and sets lookahead depth
			Alternative a = (Alternative)alternatives.elementAt(i);
			a.cache = new Lookahead[grammar.maxk+1];
			a.lookaheadDepth = GrammarAnalyzer.LOOKAHEAD_DEPTH_INIT;
		}
	}
	/**Walk the syntactic predicate and, for a rule ref R, remove
	 * the ref from the list of FOLLOW references for R (stored
	 * in the symbol table.
	 */
	public void removeTrackingOfRuleRefs(Grammar g) {
		for (int i=0; i<alternatives.size(); i++) {
			Alternative alt = getAlternativeAt(i);
			AlternativeElement elem = alt.head;
			while ( elem!=null ) {
				if ( elem instanceof RuleRefElement ) {
					RuleRefElement rr = (RuleRefElement)elem;
					RuleSymbol rs = (RuleSymbol)g.getSymbol(rr.targetRule);
					if ( rs==null ) {
						grammar.tool.error("rule "+rr.targetRule+" referenced in (...)=>, but not defined");
					}
					else {
						rs.references.removeElement(rr);
					}	
				}
				else if ( elem instanceof AlternativeBlock ) {// recurse into subrules
					((AlternativeBlock)elem).removeTrackingOfRuleRefs(g);
				}
				elem = elem.next;
			}
		}
	}
	public void setAlternatives(Vector v) {
		alternatives = v;
	}
	public void setAutoGen(boolean doAutoGen_) {
		doAutoGen = doAutoGen_;
	}
	public void setInitAction(String initAction_) {
		initAction = initAction_;
	}
	public void setLabel(String label_) { 
		label = label_; 
	}
	public void setOption(Token key, Token value) {
		if (key.getText().equals("warnWhenFollowAmbig")) {
			if (value.getText().equals("true")) {
				warnWhenFollowAmbig = true;
			} else if (value.getText().equals("false")) {
				warnWhenFollowAmbig = false;
			} else {
				grammar.tool.error("Value for warnWhenFollowAmbig must be true or false", key.getLine());
			}
		} 
		else if (key.getText().equals("generateAmbigWarnings")) {
			if (value.getText().equals("true")) {
				generateAmbigWarnings = true;
			} else if (value.getText().equals("false")) {
				generateAmbigWarnings = false;
			} else {
				grammar.tool.error("Value for generateAmbigWarnings must be true or false", key.getLine());
			}
		} 
		else {
			grammar.tool.error("Invalid subrule option: " + key.getText(), key.getLine());
		}
	}
	public String toString() {
		String s=" (";
		if ( initAction!=null ) {
			s += initAction;
		}
		for (int i=0; i<alternatives.size(); i++) {
			Alternative alt = getAlternativeAt(i);
			AlternativeElement p = alt.head;
			String pred = alt.semPred;
			if ( pred!=null ) {
				s += pred;
			}
			while (p!=null ) {
				s += p;
				p = p.next;
			}
			if ( i<(alternatives.size()-1) ) {
				s += " |";
			}
		}
		s += " )";
		return s;
	}
}
