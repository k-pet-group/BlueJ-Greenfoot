package antlr;

/**
 * <b>SOFTWARE RIGHTS</b>
 * <p>
 * ANTLR 2.5.0 MageLang Institute, 1998
 * <p>
 * We reserve no legal rights to the ANTLR--it is fully in the
 * public domain. An individual or company may do whatever
 * they wish with source code distributed with ANTLR or the
 * code generated by ANTLR, including the incorporation of
 * ANTLR, or its output, into commerical software.
 * <p>
 * We encourage users to develop software with ANTLR. However,
 * we do ask that credit is given to us for developing
 * ANTLR. By "credit", we mean that if you use ANTLR or
 * incorporate any source code into one of your programs
 * (commercial product, research project, or otherwise) that
 * you acknowledge this fact somewhere in the documentation,
 * research report, etc... If you like ANTLR and have
 * developed a nice tool with the output, please mention that
 * you developed it using ANTLR. In addition, we ask that the
 * headers remain intact in our source code. As long as these
 * guidelines are kept, we expect to continue enhancing this
 * system and expect to make other tools available as they are
 * completed.
 * <p>
 * The ANTLR gang:
 * @version ANTLR 2.5.0 MageLang Institute, 1998
 * @author Terence Parr, <a href=http://www.MageLang.com>MageLang Institute</a>
 * @author <br>John Lilley, <a href=http://www.Empathy.com>Empathy Software</a>
 */
import java.util.Hashtable;
import java.util.Enumeration;
import java.io.IOException;
import antlr.collections.impl.BitSet;
import antlr.collections.impl.Vector;

/**A Grammar holds a set of rules (which are stored
 * in a symbol table).  Most of the time a grammar
 * needs a code generator and an LLkAnalyzer too.
 */
public abstract class Grammar {
	protected Tool tool;
	protected CodeGenerator generator;
	protected LLkGrammarAnalyzer theLLkAnalyzer;
	protected Hashtable symbols;
	protected boolean buildAST = false;
	protected boolean analyzerDebug = false;
	protected boolean interactive = false;
	protected String superClass = null;

	// The token manager associated with the grammar, if any.
	// The token manager is responsible for maintaining the set of valid tokens, and
	// is conceptually shared between the lexer and parser.  This may be either a
	// LexerGrammar or a TokdefTokenManager.
	protected TokenManager tokenManager;

	// Mapping from String keys to Token option values
	protected Hashtable options;
	// Vector of RuleSymbol entries
	protected Vector rules;

	protected String preambleAction = null;
	protected String className = null;
	protected String classMemberAction = null;
	protected boolean hasSyntacticPredicate = false;
	protected boolean hasUserErrorHandling = false;

	// max lookahead that can be attempted for this parser.
	protected int maxk=1;

	// options
	protected boolean traceRules = false;
	protected boolean debuggingOutput = false;
	protected boolean defaultErrorHandler = true;

	protected String comment = null; // javadoc comment

	public Grammar(String className_, Tool tool_, String superClass) {
		className = className_;
		tool = tool_;
		symbols = new Hashtable();
		options = new Hashtable();
		rules = new Vector(100);
		this.superClass = superClass;
	}
	/** Define a rule */
	public void define(RuleSymbol rs) {
		rules.appendElement(rs);
		// add the symbol to the rules hash table
		symbols.put(rs.getId(), rs);
	}
	/** Top-level call to generate the code for this grammar */
	public abstract void generate() throws IOException;
	protected String getClassName() { return className; }
	/* Does this grammar have a default error handler? */
	public boolean getDefaultErrorHandler() {
		return defaultErrorHandler;
	}
	/** Get an integer option.  Given the name of the option find its 
	 * associated integer value.  If the associated value is not an integer or
	 * is not in the table, then throw an exception of type NumberFormatException.
	 * @param key The name of the option
	 * @return The value associated with the key.
	 */
	public int getIntegerOption(String key) throws NumberFormatException {
		Token t = (Token)options.get(key);
		if (t == null || t.getType() != ANTLRTokenTypes.INT) {
			throw new NumberFormatException();
		}
		else {
			return Integer.parseInt(t.getText());
		}
	}
	/** Get an option.  Given the name of the option find its associated value.
	 * @param key The name of the option
	 * @return The value associated with the key, or null if the key has not been set.
	 */
	public Token getOption(String key) {
		return (Token)options.get(key);
	}
	// Get name of class from which generated parser/lexer inherits
	protected abstract String getSuperClass();
	public GrammarSymbol getSymbol(String s) {
		return (GrammarSymbol) symbols.get(s);
	}
	public Enumeration getSymbols() {
		return symbols.elements();
	}
	/** Check the existence of an option in the table
	 * @param key The name of the option
	 * @return true if the option is in the table
	 */
	public boolean hasOption(String key) {
		return options.containsKey(key);
	}
	/** Is a rule symbol defined? (not used for tokens) */
	public boolean isDefined(String s) {
		return symbols.containsKey(s);
	}
	/**Process command line arguments.  Implemented in subclasses */
	public abstract void processArguments(String[] args);
	public void setCodeGenerator(CodeGenerator gen) {
		generator = gen;
	}
	public void setGrammarAnalyzer(LLkGrammarAnalyzer a) {
		theLLkAnalyzer = a;
	}
	/** Set a generic option.
	 * This associates a generic option key with a Token value.
	 * No validation is performed by this method, although users of the value
	 * (code generation and/or analysis) may require certain formats.
	 * The value is stored as a token so that the location of an error
	 * can be reported.
	 * @param key The name of the option.
	 * @param value The value to associate with the key.
	 * @return true if the option was a valid generic grammar option, false o/w
	 */
	public boolean setOption(String key, Token value) {
		options.put(key, value);
		String s = value.getText();
		int i;
		if (key.equals("k")) {
			try {
				maxk = getIntegerOption("k");
				//System.out.println("setting lookahead to " + maxk);
			} catch (NumberFormatException e) {
				tool.error("option 'k' must be an integer (was "+value.getText()+")", value.getLine());
			}
			return true;
		}
		if (key.equals("codeGenMakeSwitchThreshold")) {
			try {
				i = getIntegerOption("codeGenMakeSwitchThreshold");
			} catch (NumberFormatException e) {
				tool.error("option 'codeGenMakeSwitchThreshold' must be an integer", value.getLine());
			}
			return true;
		}
		if (key.equals("codeGenBitsetTestThreshold")) {
			try {
				i = getIntegerOption("codeGenBitsetTestThreshold");
			} catch (NumberFormatException e) {
				tool.error("option 'codeGenBitsetTestThreshold' must be an integer", value.getLine());
			}
			return true;
		}
		if (key.equals("defaultErrorHandler")) {
			if (s.equals("true")) {
				defaultErrorHandler = true;
			} else if (s.equals("false")) {
				defaultErrorHandler = false;
			} else {
				tool.error("Value for defaultErrorHandler must be true or false", value.getLine());
			}
			return true;
		}
		if (key.equals("analyzerDebug")) {
			if (s.equals("true")) {
				analyzerDebug = true;
			}
			else if (s.equals("false")) {
				analyzerDebug = false;
			}
			else {
				tool.error("option 'analyzerDebug' must be true or false", value.getLine());
			}
			return true;
		}
		if (key.equals("codeGenDebug")) {
			if (s.equals("true")) {
				analyzerDebug = true;
			}
			else if (s.equals("false")) {
				analyzerDebug = false;
			}
			else {
				tool.error("option 'codeGenDebug' must be true or false", value.getLine());
			}
			return true;
		}
		if (key.equals("classHeaderSuffix")) {
			return true;
		}
		return false;
	}
	public void setTokenManager(TokenManager tokenManager_) {
		tokenManager = tokenManager_;
	}
}
