/*
 This file is part of the BlueJ program. 
 Copyright (C) 1999-2009,2012,2014,2019,2020  Michael Kolling and John Rosenberg 
 
 This program is free software; you can redistribute it and/or 
 modify it under the terms of the GNU General Public License 
 as published by the Free Software Foundation; either version 2 
 of the License, or (at your option) any later version. 
 
 This program is distributed in the hope that it will be useful, 
 but WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 GNU General Public License for more details. 
 
 You should have received a copy of the GNU General Public License 
 along with this program; if not, write to the Free Software 
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA. 
 
 This file is subject to the Classpath exception as provided in the  
 LICENSE.txt file that accompanied this code.
 */
package bluej.debugger.jdi;

import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;

import bluej.debugger.Debugger.EventHandlerRunnable;
import bluej.utility.Debug;
import threadchecker.OnThread;
import threadchecker.Tag;
import bluej.debugger.DebuggerEvent;

import com.sun.jdi.ReferenceType;
import com.sun.jdi.VMDisconnectedException;
import com.sun.jdi.VirtualMachine;
import com.sun.jdi.event.BreakpointEvent;
import com.sun.jdi.event.ClassPrepareEvent;
import com.sun.jdi.event.Event;
import com.sun.jdi.event.EventIterator;
import com.sun.jdi.event.EventQueue;
import com.sun.jdi.event.EventSet;
import com.sun.jdi.event.ExceptionEvent;
import com.sun.jdi.event.LocatableEvent;
import com.sun.jdi.event.StepEvent;
import com.sun.jdi.event.ThreadDeathEvent;
import com.sun.jdi.event.ThreadStartEvent;
import com.sun.jdi.event.VMDeathEvent;
import com.sun.jdi.event.VMDisconnectEvent;
import com.sun.jdi.event.VMStartEvent;
import com.sun.jdi.request.EventRequest;
import com.sun.jdi.request.StepRequest;

/**
 * Event handler class to handle events coming from the remote VM.
 *
 * @author  Michael Kolling
 */
@OnThread(Tag.VMEventHandler)
class VMEventHandler extends Thread
{
    final static String DONT_RESUME = "dontResume";
    
    private final VMReference vm;
    
    /**
     * A class to represent a thread halted/resumed event.
     */
    @OnThread(Tag.Any)
    private class ThreadEvent
    {
        ThreadEvent(JdiThread thread, boolean state)
        {
            this.thread = thread;
            this.state = state;
        }
        JdiThread thread;
        boolean state; // true for halted, false for continued
    }

    /**
     * This is a queue that the VMEventHandler thread reads from.  The Object items are always either:
     *  - EventSet, which come from a sub-thread that forwards the events into our queue
     *  - ThreadEvent, which is generated by VMReference but should be handled by us.
     *  - EventHandlerRunnable, which is a custom task to run on our thread.
     */
    @OnThread(Tag.Any)
    private final LinkedBlockingQueue<Object> incomingEvents = new LinkedBlockingQueue<>();

    @OnThread(Tag.Any)
    private final AtomicBoolean exiting = new AtomicBoolean(false);
    
    private final Thread subThread;
    
    @OnThread(Tag.Any)
    VMEventHandler(VMReference vm, VirtualMachine vmm)
    {
        super("vm-event-handler");
        this.vm = vm;
        // Start a simple thread to forward events from the vmm eventQueue into our own queue:
        // We have to do this so we can listen to multiple incoming event sources in our own thread:
        subThread = new Thread()
        {
            @Override
            public void run()
            {
                while (!exiting.get())
                {
                    try
                    {
                        EventSet eventSet = vmm.eventQueue().remove();
                        incomingEvents.add(eventSet);
                    }
                    catch (InterruptedException e)
                    {
                    }
                    catch (VMDisconnectedException discExc)
                    {
                        // A VMDisconnectedException is always preceded by a VMDisconnectEvent (see docs of remove(), above)
                        // Thus if we see the exception, we'll already have forwarded that event to the main process,
                        // and we can just happily terminate our own thread:
                        return;
                    }
                }
            }
        };
        subThread.start();
        start();  // will execute our own run method
    }

    @OnThread(value = Tag.VMEventHandler, ignoreParent = true)
    public void run()
    {
        while (!exiting.get())
        {
            try
            {
                Object event = incomingEvents.take();
                
                if (event instanceof EventSet)
                {
                    EventSet eventSet = (EventSet) event;
                    // From the JDK documentation
                    // The events that are grouped in an EventSet are restricted in the following ways:
                    //   * Always singleton sets:
                    //     o VMStartEvent
                    //     o VMDisconnectEvent 
                    //   * Only with other VMDeathEvents:
                    //     o VMDeathEvent 
                    //   * Only with other ThreadStartEvents for the same thread:
                    //     o ThreadStartEvent 
                    //   * Only with other ThreadDeathEvents for the same thread:
                    //     o ThreadDeathEvent 
                    //   * Only with other ClassPrepareEvents for the same class:
                    //     o ClassPrepareEvent 
                    //   * Only with other ClassUnloadEvents for the same class:
                    //     o ClassUnloadEvent 
                    //   * Only with other AccessWatchpointEvents for the same field access:
                    //     o AccessWatchpointEvent 
                    //   * Only with other ModificationWatchpointEvents for the same field modification:
                    //     o ModificationWatchpointEvent 
                    //   * Only with other ExceptionEvents for the same exception occurrence:
                    //     o ExceptionEvent 
                    //   * Only with other MethodExitEvents for the same method exit:
                    //     o MethodExitEvent 
                    //   * Only with other members of this group, at the same location and in the same thread:
                    //     o BreakpointEvent
                    //     o StepEvent
                    //     o MethodEntryEvent 

                    boolean addToSuspendCount = true;

                    // iterate through all events in the set
                    EventIterator it = eventSet.eventIterator();

                    boolean examineSaidSkipUpdates = false;
                    boolean gotBPEvent = false;

                    while (it.hasNext())
                    {
                        Event ev = it.nextEvent();

                        examineSaidSkipUpdates |= screenEvent(ev);

                        // for breakpoint and step events, we may want
                        // to leave the relevant thread suspended. If the dontResume
                        // property for the event is set, then lets do this.
                        if (ev.request() != null)
                        {
                            if (addToSuspendCount && ev.request().getProperty(DONT_RESUME) != null)
                            {
                                if (ev instanceof LocatableEvent)
                                {
                                    LocatableEvent le = (LocatableEvent) ev;
                                    le.thread().suspend();
                                    addToSuspendCount = false;
                                    // a step and breakpoint can be hit at the same
                                    // time - make sure to only suspend once
                                    gotBPEvent |= (ev instanceof BreakpointEvent);
                                }
                            }
                        }
                    }

                    // Now go through again to do proper processing:
                    it = eventSet.eventIterator();
                    while (it.hasNext())
                    {
                        Event ev = it.nextEvent();

                        // do some processing with this event
                        // this calls back into VMReference
                        handleEvent(ev, examineSaidSkipUpdates, gotBPEvent);
                    }

                    // resume the VM
                    eventSet.resume();
                }
                else if (event instanceof ThreadEvent)
                {
                    ThreadEvent halted = (ThreadEvent) event;
                    if (halted.state)
                    {
                        vm.threadHaltedEvent(halted.thread);
                    }
                    else
                    {
                        vm.threadResumedEvent(halted.thread);
                    }
                }
                else if (event instanceof EventHandlerRunnable)
                {
                    ((EventHandlerRunnable) event).run();
                }
            }
            catch (InterruptedException exc) { }
            catch (VMDisconnectedException discExc)
            {
                // The forwarding thread should already have seen the VM disconnection itself, but just in case,
                // we can tell it to exit now that we know about it.  This will also lead to us ending our thread:
                exiting.set(true);
            }
        }
    }
    
    /**
     * Emit a thread halted/resumed event.
     * 
     * @param thr   The thread for which the event occurred
     * @param halted  True if the thread was halted, false if resumed
     */
    @OnThread(Tag.Any)
    public synchronized void emitThreadEvent(JdiThread thr, boolean halted)
    {
        incomingEvents.add(new ThreadEvent(thr, halted));
    }
    
    private static int getStepType(StepEvent ev)
    {
        EventRequest req = ev.request();
        if (req instanceof StepRequest)
        {
            int stepDepth = ((StepRequest)req).depth();
            
            if (stepDepth == StepRequest.STEP_INTO)
                return DebuggerEvent.THREAD_HALT_STEP_INTO;
            else if (stepDepth == StepRequest.STEP_OVER)
                return DebuggerEvent.THREAD_HALT_STEP_OVER;
            // Otherwise, fall-through:
        }
        
        return DebuggerEvent.THREAD_HALT_UNKNOWN;
    }
    
    @OnThread(Tag.VMEventHandler)
    private boolean screenEvent(Event event)
    {
        if (event instanceof BreakpointEvent) {
            return vm.screenBreakpointEvent((LocatableEvent)event, DebuggerEvent.THREAD_BREAKPOINT);
        } else if (event instanceof StepEvent) {
            return vm.screenBreakpointEvent((LocatableEvent)event, getStepType((StepEvent)event));
        }
        return false;
    }
        
    private void handleEvent(Event event, boolean skipUpdate, boolean gotBP)
    {
        if (event instanceof VMStartEvent) {
            vm.vmStartEvent((VMStartEvent) event);
        } else if (event instanceof VMDeathEvent) {
            // vm.vmExitEvent();
        } else if (event instanceof VMDisconnectEvent) {
            vm.vmDisconnectEvent();
        } else if (event instanceof ExceptionEvent) {
            vm.exceptionEvent((ExceptionEvent)event);
        } else if (event instanceof BreakpointEvent) {
            vm.breakpointEvent((LocatableEvent)event, DebuggerEvent.THREAD_BREAKPOINT, skipUpdate);
        } else if (event instanceof StepEvent) {
            // If we get a step and hit a breakpoint at the same time,
            // we only report the breakpoint.
            if (! gotBP) {
                vm.breakpointEvent((LocatableEvent)event, getStepType((StepEvent)event), skipUpdate);
            }
        } else if (event instanceof ThreadStartEvent) {
            vm.threadStartEvent((ThreadStartEvent)event);
        } else if (event instanceof ThreadDeathEvent) {
            vm.threadDeathEvent((ThreadDeathEvent)event);
        } else if (event instanceof ClassPrepareEvent) {
            classPrepareEvent(event);
        } else {
            //Debug.message("[VM event] unhandled: " + event);
        }
    }
    
    private boolean classPrepareEvent(Event event)
    {
        ClassPrepareEvent cle = (ClassPrepareEvent)event;
        ReferenceType refType = cle.referenceType();
        
        if(refType.name().equals(VMReference.SERVER_CLASSNAME)) {
            vm.serverClassPrepared();
        }
        return true;
    }


    @OnThread(Tag.Any)
    public void queueRunnable(EventHandlerRunnable runnable)
    {
        try
        {
            incomingEvents.put(runnable);
        }
        catch (InterruptedException e)
        {
            // Shouldn't happen:
            Debug.reportError(e);
        }
    }
}
